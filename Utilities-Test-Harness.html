<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Utilties</title>
    <style>
        p,
        ul {
            width: 60ch;
        }

        a {
            color: #000;
        }
    </style>
</head>

<body>
    <h1 id='0'>Utilities Test Harness</h1>
    <main>
        <section>
            <ul>
                <li><a href="#1">accumulatedAverage</a></li>
                <li><a href="#2">clampRange</a></li>
                <li><a href="#3">normaliseRange</a></li>
                <li><a href="#4">liniarInterpolate</a></li>
                <li><a href="#5">mapRanges</a></li>
                <li><a href="#6">rangeBetween</a></li>
                <li><a href="#7">rangeFrom</a></li>
                <li><a href="#8">inRange</a></li>
                <li><a href="#9">loopRange</a></li>
                <li><a href="#10">intersectArrays</a></li>
                <li><a href="#11">unionArrays</a></li>
                <li><a href="#12">exercise</a></li>
                <li><a href="#13">Base 64 Encoding</a></li>
                <li><a href="#14">Base 64 Decoding</a></li>
                <li><a href="#15">Short Day</a></li>
                <li><a href="#16">Long Day</a></li>
                <li><a href="#17">Short Month</a></li>
                <li><a href="#18">Long Month</a></li>
            </ul>
            <p>The above functions make considerable use of the technique called currying to return a specialised
                function. This saves on suppling parameters that are not expected to change.</p>
            <h4>NB: The functions have been prepared with no input validation or additional error checking.</h4>
        </section>
        <hr>

        <h2 id='1'><a href="#0">Accumulated Average</a></h2>
        <section>
            <h3>Parameters</h3>
            <h4>Initial call</h4>
            <ul>
                <li>averageToDate: Current average before the new Value arrived. (defaulted to 0)</li>
                <li>sampleSize: Number of values in the sample, including the new Value. (defaulted to 0)</li>
            </ul>
            <h4>Subsequent calls</h4>
            <ul>
                <li>newValue - New data point to be included in the average calculation.</li>
                <li>newAverge - Replacement value of the averageToDate. (optional)</li>
                <li>newSampleSize - Replacement value of the sampleSize. (optional)</li>
            </ul>
            <h4>Return Value</h4>
            <p>The new calculated average.</p>
            <h3>Description</h3>
            <p>Utility for recalculating an average as the sample size increased. There are two ways of using the
                function, one-off and incremental, but both employ partial application.</p>
            <p>One-off, involves calling acculmulateAverage with the current average and the size of the sample (number
                of values from which the average is calculated.) This provides the partial application (specilised
                function) that can then be called with the value to the included in the average.</p>
            <code>Utility.accumulatedAverage(currentAverage, sampleSize)(newValue)</code>
            <p>The incremental appraoch of using the function involves placing the initial call without parameters (or
                with the defaults), to get the specialised function. </p>
            <code>var accumulateAverage = Utility.accumulatedAverage();</code><br>
            <code>var newAverage = accumulateAverage(newSample)); // newAverage = (0 + newSample) / (0 + 1)</code><br>
            <p>Subsequent calls to accumulateAverage with include additional values as part of the new average.</p>
        </section>
        <hr>

        <h2 id='2'><a href="#0">Clamp Range</a></h2>
        <section>
            <h3>Parameters</h3>
            <h4>Initial call</h4>
            <ul>
                <li>min - lower boundry of the range.</li>
                <li>max - upper boundry of the range.</li>
            </ul>
            <h4>Subsequent calls</h4>
            <ul>
                <li>value - datum to be clamped.</li>
            </ul>
            <h4>Return Value</h4>
            <p>A value within the clamped range.</p>
            <h3>Description</h3>
            <p>Function that restricts a value to within a given numeric range. Initialised with the lower and upper
                boundries
                of a
                range, this function returns another specialised function.</p>
            <p>When the specialised function is called with a single number, the value may be changed to bring it within
                the predefined range.</p>
            <p>

                If the input value is below the lower boundries the output from the function will be the lower boundary.
                Likewise, if the input value is above the upper boundries the output from the function will be the upper
                boundary.
            </p>
            <p>If the input value is within the boundries the output from the function will be the input value.</p>
        </section>
        <hr>

        <h2 id='3'><a href="#0">Normalise Range</a></h2>
        <section>
            <h3>Parameters</h3>
            <h4>Initial call</h4>
            <ul>
                <li>start - lower boundry of the range.</li>
                <li>end - upper boundry of the range.</li>
            </ul>
            <h4>Subsequent calls</h4>
            <ul>
                <li>value - datum to be normalised (set to a value between 0 and 1 proportional to the given range.)
                </li>
            </ul>
            <h4>Return Value</h4>
            <p>A value between 0 and 1.</p>
            <h3>Description</h3>
            <p>The NormaliseRange function takes in the min and max values of a range in which future values are to be
                normalised, and returns a specialised function.</p>
            <p>When the specialised function is called with a value within the range the result is a value proportional
                to the range (between 0 and 1.)</p>
            <p>Input values outside the expected range will be either less than 0 or greater than 1.</p>
        </section>
        <hr>

        <h2 id='4'><a href="#0">Liniar Interpolate</a></h2>
        <section>
            <h3>Parameters</h3>
            <h4>Initial call</h4>
            <ul>
                <li>start - lower boundry of the range.</li>
                <li>end - upper boundry of the range.</li>
            </ul>
            <h4>Subsequent calls</h4>
            <ul>
                <li>value - datum (between 0 and 1) to be interpolated.</li>
            </ul>
            <h4>Return Value</h4>
            <p>A value between the start and end values, proportional to the input value.</p>
            <h3>Description</h3>
            <p>This function converts a normalised value (beweet 0 and 1), and initilised with a given range, returns a
                value within the range proportional to the input value.</p>
        </section>
        <hr>

        <h2 id='5'><a href="#0">Map Ranges</a></h2>
        <section>
            <h3>Parameters</h3>
            <h4>Initial call</h4>
            <ul>
                <li>fromMin - lower boundry of the source range.</li>
                <li>fromMax - upper boundry of the source range.</li>
                <li>toMin - lower boundry of the target range.</li>
                <li>toMax - upper boundry of the target range.</li>
            </ul>
            <h4>Subsequent calls</h4>
            <ul>
                <li>value - datum from the source range to be mapped into the target range.</li>
            </ul>
            <h4>Return Value</h4>
            <p>A value in the target range, when the input value is from the source range, otherwise unknown.</p>
            <h3>Description</h3>
            <p>The Map Ranges function is quite self explanatory. Initialised with a source and target range, and given
                an input value (within the source range), it returns a value in the target range with the same
                normalised proportion.</p>
        </section>
        <hr>

        <h2 id='6'><a href="#0">Range Between</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>min - lower boundry of the range.</li>
                <li>max - upper boundry of the range.</li>
                <li>step - size of the interval between values in the range (defaulted to 1.)</li>
            </ul>
            <h4>Return Value</h4>
            <p>A new array containing the numbers between <i>min</i> and <i>max</i> - 1, in <i>step</i> intervals.</p>
            <h3>Description</h3>
            <p>RangeBetween is a generator function that produces an array of numbers between <i>min</i> and <i>max</i>
                (- 1) in <i>step</i> intervals (default value is 1.)</p>
        </section>
        <hr>

        <h2 id='7'><a href="#0">Range From</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>init - initial value of the range.</li>
                <li>len - number of values in the outputrange.</li>
                <li>step - size of the interval between values in the range (defaulted to 1.)</li>
            </ul>
            <h4>Return Value</h4>
            <p>A new array containing <i>len</i> numbers starting from <i>init</i>, in <i>step</i> intervals.</p>
            <p>A new array containing the a numbers.</p>
            <h3>Description</h3>
            <p>Similar to the RangeBetween function, this function generates an array of <i>len</i> numbers commencing
                with <i>init</i> and varying by <i>step</i>. The step parameter can be a fixed value (defaulted to 1) or
                a function using the index as an input.</p>
        </section>
        <hr>

        <h2 id='8'><a href="#0">InRange</a></h2>
        <section>
            <h3>Parameters</h3>
            <h4>Initial call</h4>
            <ul>
                <li>from - lower boundry of the primary range.</li>
                <li>to - upper boundry of the primary range.</li>
            </ul>
            <h4>Subsequent calls</h4>
            <ul>
                <li>from - lower boundry of the secondary range.</li>
                <li>to - upper boundry of the secondary range.</li>
            </ul>
            <h4>Return Value</h4>
            <p>Boolean value indicating the ranges overlap or a value is within a given range.</p>
            <h3>Description</h3>
            <p>This function supports two use cases:</p>
            <ol>
                <li>Confirm two ranges overloap.</li>
                <li>Confirm a value lies within a primary range.</li>
            </ol>
        </section>
        <hr>

        <h2 id='9'><a href="#0">LoopRange</a></h2>
        <section>
            <h3>Parameters</h3>
            <h4>Initial call</h4>
            <ul>
                <li>max - maximum output value of the range.</li>
                <li>min - minimal output value of the range (optional, defaulted to zero).</li>
            </ul>
            <h4>Subsequent calls</h4>
            <ul>
                <li>cur - Current value within the range.</li>
                <li>dir - Direction of change (1 to increase and -1 to decrease.)</li>
            </ul>
            <h4>Return Value</h4>
            <p>Calculated new value within the range.</p>
            <h3>Description</h3>
            <p>Calculates a new value in a sequence based on the current (<i>cur</i>) input. The value increases or
                decreases based on the direction (<i>dir</i>) value (1 to increase, -1 to decrease.) The value changes
                within a defined range up to a maximum (<i>max</i>) and minimum (<i>min</i>), which is an optional input
                with a default of zero.</p>
            <p>When the value exceeds the bounds of the range it loops round to the opposite end of the range.</p>
        </section>
        <hr>

        <h2 id='10'><a href="#0">Intersect Arrays</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>arrays - One or more arrays from which the intersect is to be extracted.</li>
            </ul>
            <h4>Return Value</h4>
            <p>A new array containing only those values found in all the given arrays.</p>
            <h3>Description</h3>
            <p>Extracts the common values of all the input arrays into a new array of distinct values.</p>
        </section>
        <hr>

        <h2 id='11'><a href="#0">Union Arrays</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>arrays - One or more arrays from which the union is to be extracted.</li>
            </ul>
            <h4>Return Value</h4>
            <p>A new array containing a distinct list of values from all of the given arrays.</p>
            <h3>Description</h3>
            <p>Extracts a list of all the values from the input arrays into a new array of distinct values.</p>
        </section>
        <hr>

        <h2 id='12'><a href="#0">Exercise</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>expected - The value anticipated to be the result.</li>
                <li>actual - The value calculated as the result.</li>
                <li>id - Reference for the specific exercise. (optional)</li>
            </ul>
            <h4>Return Value</h4>
            <p>Result of the comparison (true or false.)</p>
            <h3>Description</h3>
            <p>A simple mechanism for ad-hoc testing of a pure function.</p>
        </section>
        <hr>

        <h2 id='13'><a href="#0">Base 64 Encoding</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>Raw data such as a binary buffer</li>
            </ul>
            <h4>Return Value</h4>
            <p>Base 64 encoded version of the input raw data.</p>
            <h3>Description</h3>
            <p>Applies Base64 encoding of supplied data.</p>
        </section>

        <h2 id='14'><a href="#0">Base 64 Decoding</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>Data in Base64 encoding</li>
            </ul>
            <h4>Return Value</h4>
            <p>Decodes version of the Base64 encoded input data.</p>
            <h3>Description</h3>
            <p>Applies Base64 decoding of supplied encloded data.</p>
        </section>
        <hr>

        <h2 id='15'><a href="#0">Date Strings - Short Day</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>lang - Locale string (defaulted to gb-GB)</li>
                <li>idx - Number in the range of 0-6 (optional on initial call, mandatory on second call.)</li>
            </ul>
            <h4>Return Value</h4>
            <p>String representing the short form of the day of week in the language of the given locale code.</p>
            <h3>Description</h3>
            <p>Provides the short form of the day of week in the given locale, based in a numeric value in the range of
                0 to 6.</p>
        </section>

        <h2 id='16'><a href="#0">Date Strings - Long Day</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>lang - Locale string (defaulted to gb-GB)</li>
                <li>idx - Number in the range of 0-6 (optional on initial call, mandatory on second call.)</li>
            </ul>
            <h4>Return Value</h4>
            <p>String representing the long form of the day of week in the language of the given locale code.</p>
            <h3>Description</h3>
            <p>Provides the long form of the day of week in the given locale, based in a numeric value in the range of 0
                to 6.</p>
        </section>

        <h2 id='17'><a href="#0">Date Strings - Short Month</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>lang - Locale string (defaulted to gb-GB)</li>
                <li>idx - Number in the range of 0-11 (optional on initial call, mandatory on second call.)</li>
            </ul>
            <h4>Return Value</h4>
            <p>String representing the short form of the month of year in the language of the given locale code.</p>
            <h3>Description</h3>
            <p>Provides the short form of the month of year in the given locale, based in a numeric value in the range
                of 0 to 11.</p>
        </section>

        <h2 id='18'><a href="#0">Date Strings - Long Month</a></h2>
        <section>
            <h3>Parameters</h3>
            <ul>
                <li>lang - Locale string (defaulted to gb-GB)</li>
                <li>idx - Number in the range of 0-11 (optional on initial call, mandatory on second call.)</li>
            </ul>
            <h4>Return Value</h4>
            <p>String representing the long form of the month of year in the language of the given locale code.</p>
            <h3>Description</h3>
            <p>Provides the long form of the month of year in the given locale, based in a numeric value in the range of
                0 to 11.</p>
        </section>
        <hr>
    </main>

    <script src="utilities.js"></script>
    <script>
        console.log('\nAccumulated Average');
        console.log(`\tUtilities.accumulatedAverage(9, 5)(9) = ${Utilities.accumulatedAverage(9, 5)(9)}
        Explanation : 9 * 5 = 45, + 9 = 54, / 6 = 9.`);
        console.log(`\tUtilities.accumulatedAverage(9, 5)(45) = ${Utilities.accumulatedAverage(9, 5)(45)}
        Explanation : 9 * 5 = 45, + 45 = 90, / 6 = 15.`);
        var newAverage = Utilities.accumulatedAverage();
        console.log(`\tnewAverage(1) = ${newAverage(1)} = 1.0`);
        console.log(`\tnewAverage(2) = ${newAverage(2)} = 1.5`);
        console.log(`\tnewAverage(3) = ${newAverage(3)} = 2.0`);
        console.log(`\tnewAverage(4) = ${newAverage(4)} = 2.5`);
        console.log(`\tnewAverage(5) = ${newAverage(5)} = 3.0`);

        console.log('\nClamp Range: 50 to 60');
        var clampedRange = Utilities.clampRange(50, 60);
        console.log(`\tclampedRange(45) = ${clampedRange(45)}`);
        console.log(`\tclampedRange(50) = ${clampedRange(50)}`);
        console.log(`\tclampedRange(55) = ${clampedRange(55)}`);
        console.log(`\tclampedRange(60) = ${clampedRange(60)}`);
        console.log(`\tclampedRange(65) = ${clampedRange(65)}`);

        console.log('\nNormal Range: 50 to 60');
        var normalizedRange = Utilities.normaliseRange(50, 60);
        console.log(`\tnormalizedRange(45) = ${normalizedRange(45)}`);
        console.log(`\tnormalizedRange(50) = ${normalizedRange(50)}`);
        console.log(`\tnormalizedRange(55) = ${normalizedRange(55)}`);
        console.log(`\tnormalizedRange(60) = ${normalizedRange(60)}`);
        console.log(`\tnormalizedRange(65) = ${normalizedRange(65)}`);

        console.log('\nLiniar Interpolate: 50 to 60');
        var liniarInterlopated = Utilities.liniarInterpolate(50, 60);
        console.log(`\tliniarInterlopated(0.00) = ${liniarInterlopated(0)}`);
        console.log(`\tliniarInterlopated(0.25) = ${liniarInterlopated(0.25)}`);
        console.log(`\tliniarInterlopated(0.50) = ${liniarInterlopated(0.5)}`);
        console.log(`\tliniarInterlopated(0.75) = ${liniarInterlopated(0.75)}`);
        console.log(`\tliniarInterlopated(1.00) = ${liniarInterlopated(1)}`);

        console.log('\nMap Ranges: 50~60 to 80~100');
        var mappedRanges = Utilities.mapRanges(50, 60, 80, 100);
        console.log(`\tmappedRanges(45) = ${mappedRanges(45)}`);
        console.log(`\tmappedRanges(50) = ${mappedRanges(50)}`);
        console.log(`\tmappedRanges(55) = ${mappedRanges(55)}`);
        console.log(`\tmappedRanges(60) = ${mappedRanges(60)}`);
        console.log(`\tmappedRanges(65) = ${mappedRanges(65)}`);

        console.log('\nRange Between');
        console.log(`\tUtilities.rangeBetween(10, 20) = [${Utilities.rangeBetween(10, 20)}]`);
        console.log(`\tUtilities.rangeBetween(10, 20, 2) = [${Utilities.rangeBetween(10, 20, 2)}]`);

        console.log('\nRange From (numeric)');
        console.log(`\tUtilities.rangeFrom() = [${Utilities.rangeFrom()}]`);
        console.log(`\tUtilities.rangeFrom(10) = [${Utilities.rangeFrom(10)}]`);
        console.log(`\tUtilities.rangeFrom(10, 20) = [${Utilities.rangeFrom(10, 20)}]`);
        console.log(`\tUtilities.rangeFrom(10, 20, 2) = [${Utilities.rangeFrom(10, 20, 2)}]`);
        console.log('\nRange From (function)');
        function power2(x) { return 2 ** x; }
        console.log(`\tUtilities.rangeFrom(10, 20, power2) = [${Utilities.rangeFrom(10, 10, power2)}]`);

        console.log('\nIn Range (value in range)');
        console.log('Given the primary range of 100 - 200:');
        var valueRange = Utilities.inRange(100, 200);
        console.log(`\tUtilities.inRange(100, 200)(50) = ${valueRange(50)}`);
        console.log(`\tUtilities.inRange(100, 200)(99) = ${valueRange(99)}`);
        console.log(`\tUtilities.inRange(100, 200)(100) = ${valueRange(100)}`);
        console.log(`\tUtilities.inRange(100, 200)(101) = ${valueRange(101)}`);
        console.log(`\tUtilities.inRange(100, 200)(199) = ${valueRange(199)}`);
        console.log(`\tUtilities.inRange(100, 200)(200) = ${valueRange(200)}`);
        console.log(`\tUtilities.inRange(100, 200)(201) = ${valueRange(201)}`);
        console.log(`\tUtilities.inRange(100, 200)(250) = ${valueRange(250)}`);

        console.log('\nIn Range (overlapping ranges)');
        console.log('Given the primary range of 100 - 200:');
        var primaryRange = Utilities.inRange(100, 200);
        console.log(`\tUtilities.inRange(100, 200)(1, 75) = ${primaryRange(1, 75)}`);
        console.log(`\tUtilities.inRange(100, 200)(50, 150) = ${primaryRange(50, 150)}`);
        console.log(`\tUtilities.inRange(100, 200)(150, 250) = ${primaryRange(150, 250)}`);
        console.log(`\tUtilities.inRange(100, 200)(250, 300) = ${primaryRange(250, 300)}`);
        console.log(`\tUtilities.inRange(100, 200)(50, 300) = ${primaryRange(50, 300)}`);

        console.log('\nLoop Range (zero indexed)');
        var zeroIndexed = Utilities.loopRange(9);
        var inc = 1;
        var dec = -1;
        var incValue = 4;
        console.log(`\tIncreased from ${incValue}`);
        for (var i = 1; i <= 10; i++) {
            console.log(`\t${i}\tUtilities.loopRange(9) from ${incValue} to ${incValue = zeroIndexed(incValue, inc)}`);
        }
        var decValue = 4;
        console.log(`\tDecreased from ${decValue}`);
        for (var i = 1; i <= 10; i++) {
            console.log(`\t${i}\tUtilities.loopRange(9) from ${decValue} to ${decValue = zeroIndexed(decValue, dec)}`);
        }

        console.log('\nLoop Range (one indexed)');
        var oneIndexed = Utilities.loopRange(9, 1);
        incValue = 4;
        console.log(`\tIncreased from ${incValue}`);
        for (var i = 1; i <= 10; i++) {
            console.log(`\t${i}\tUtilities.loopRange(9, 1) from ${incValue} to ${incValue = oneIndexed(incValue, inc)}`);
        }
        decValue = 4;
        console.log(`\tDecreased from ${decValue}`);
        for (var i = 1; i <= 10; i++) {
            console.log(`\t${i}\tUtilities.loopRange(9, 1) from ${decValue} to ${decValue = oneIndexed(decValue, dec)}`);
        }

        console.log('\nIntersect Array: Extract values common to all given arrays');
        console.log('Given the following Arrays:');
        var alpha = Utilities.rangeFrom(1, 4);
        console.log(`\tAlpha: [${alpha}]`);
        var beta = Utilities.rangeFrom(2, 4);
        console.log(`\tBeta: [${beta}]`);
        var delta = Utilities.rangeFrom(3, 4);
        console.log(`\tDelta: [${delta}]`);
        var zeta = Utilities.rangeFrom(10, 4, 10);
        console.log(`\tZeta: [${zeta}]`);
        console.log('Calculate:\n');
        console.log(`\tUtilities.intersectArrays(alpha) = [${Utilities.intersectArrays(alpha)}]`);
        console.log(`\tUtilities.intersectArrays(alpha, beta) = [${Utilities.intersectArrays(alpha, beta)}]`);
        console.log(`\tUtilities.intersectArrays(alpha, beta, delta) = [${Utilities.intersectArrays(alpha, beta, delta)}]`);
        console.log(`\tUtilities.intersectArrays(alpha, zeta) = [${Utilities.intersectArrays(alpha, zeta)}]`);

        console.log('\nUnion Array: Extract a distinct set of values from all given arrays');
        console.log('Given the following Arrays:');
        var alpha = Utilities.rangeFrom(1, 4);
        console.log(`\tAlpha: [${alpha}]`);
        var beta = Utilities.rangeFrom(2, 4);
        console.log(`\tBeta: [${beta}]`);
        var delta = Utilities.rangeFrom(3, 4);
        console.log(`\tDelta: [${delta}]`);
        var zeta = Utilities.rangeFrom(10, 4, 10);
        console.log(`\tZeta: [${zeta}]`);
        console.log('Calculate:\n');
        console.log(`\tUtilities.unionArrays(alpha) = [${Utilities.unionArrays(alpha)}]`);
        console.log(`\tUtilities.unionArrays(alpha, beta) = [${Utilities.unionArrays(alpha, beta)}]`);
        console.log(`\tUtilities.unionArrays(alpha, beta, delta) = [${Utilities.unionArrays(alpha, beta, delta)}]`);
        console.log(`\tUtilities.unionArrays(alpha, zeta) = [${Utilities.unionArrays(alpha, zeta)}]`);

        console.log('\nExercise');
        console.log(`\t\tResult: ${Utilities.exercise([10], [10])}`);
        console.log(`\t\tResult: ${Utilities.exercise([10], [9, 11], 'TWO')}`);
        console.log(`\t\tResult: ${Utilities.exercise([10], [9, 10, 11].filter(x => x % 10), 'three')}`);
        console.log(`\t\tResult: ${Utilities.exercise([10], [9, 10, 11].filter(x => !(x % 10)), 4)}`);

        console.log('\nBase64');
        var b64EncodeTest = 'Hello World!';
        console.log(`\tEncoding of '${b64EncodeTest}' = '${Utilities.base64EncodeUnicode(b64EncodeTest)}'`);
        var b64DecodeTest = 'SGVsbG8gV29ybGQh';
        console.log(`\tDecoding of '${b64DecodeTest}' = '${Utilities.base64DecodeUnicode(b64DecodeTest)}'`);

        console.log('\nDate Strings');
        console.log('\tDay of Week (short) [');
        for (day = 0; day < 7; day++) {
            console.log(`\t\tDay ${day} (UK) = '${Utilities.shortDay()(day)}'`);
        }
        console.log('\tDay of Week (long)');
        var longDayFrench = Utilities.longDay('fr-FR')
        for (day = 0; day < 7; day++) {
            console.log(`\t\tDay ${day} (FR) = '${longDayFrench(day)}'`);
        }
        console.log('\tMonth of Year (short)');
        var shortMonthGerman = Utilities.shortMonth('de-DE');
        for (month = 0; month < 12; month++) {
            console.log(`\t\tMonth ${month} (DE) = '${shortMonthGerman(month)}'`);
        }
        console.log('\tMonth of Year (long)');
        for (month = 0; month < 12; month++) {
            console.log(`\t\tMonth ${month} (UK) = '${Utilities.longMonth()(month)}'`);
        }
    </script>
</body>

</html>